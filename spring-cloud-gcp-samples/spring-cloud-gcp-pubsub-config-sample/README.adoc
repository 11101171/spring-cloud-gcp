= Spring Cloud GCP Pub/Sub Configuration Management Code Sample

This code sample demonstrates automated configuration management using Spring Cloud Config, Spring Cloud Bus and GCP Pub/Sub.
The sample app consists of a configuration server and a small web application that subscribes to the server to be notified of property changes.

Configuration server runs on port `8888`, and can read configuration from a local filesystem (useful for exploring the sample) or from a source control system.
When the server is notified that new configuration is available, it fetches the updated configuration and sends it out via Spring Cloud Bus.

Under the hood, Spring Cloud Bus uses the Spring Cloud Stream binder for Cloud Pub/Sub to send a message to a topic named `springCloudBus`.
The client uses the same binder with an anonymous subscription to receive notifications, and provides an HTTP endpoint `/message` for printing the dynamically updated message value.

Technically, every configuration server happens to also be a configuration client, so it subscribes to the configuration changes that it sends.
But in this set of demo applications, the configuration server does not use any dynamic configuration, so the only evidence of it acting as a client is in the additional anonymous Cloud Pub/Sub subscription that gets created when the server starts up.

== Setup

1. Configure your GCP project ID and credentials by following link:../../docs/src/main/asciidoc/core.adoc#project-id[these instructions].
+
Alternatively, if you have the https://cloud.google.com/sdk/[Google Cloud SDK] installed and initialized, and are logged in with https://developers.google.com/identity/protocols/application-default-credentials[application default credentials], Spring will auto-discover those parameters for you.

2. Make sure that GCP Cloud Pub/Sub API is enabled, either through link:https://console.cloud.google.com/apis/api/pubsub.googleapis.com[Google Cloud Console] or with the following `gcloud` command:

  gcloud services enable pubsub.googleapis.com

== Demo with local filesystem

1. Create a temporary directory `/tmp/config`.
Alternatively, update `spring.cloud.config.server.native.searchLocationsconfig` property in configuration server's link:spring-cloud-gcp-pubsub-config-sample-server/src/main/resources/application.properties[application.properties] with the directory you will use.
Make sure to specify `file:` prefix if using absolute paths.

2. In separate terminal windows, start the `spring-cloud-gcp-pubsub-config-sample-server-local` and `spring-cloud-gcp-pubsub-config-sample-client` applications:

  cd spring-cloud-gcp-samples/spring-cloud-gcp-pubsub-config-sample
  mvn spring-boot:run -pl spring-cloud-gcp-pubsub-config-sample-server-local

  cd spring-cloud-gcp-samples/spring-cloud-gcp-pubsub-config-sample
  mvn spring-boot:run -pl spring-cloud-gcp-pubsub-config-sample-client

2. Visit http://localhost:8080/message client endpoint in a browser; observe the default value of `none` printed on the page.
This happens because there is no configuration available for config server yet.

4. Place a file named `application.properties` with the following contents into the directory above:
+
----
example.message = message from the local filesystem
----

5. In the config _server_ terminal, observe refresh activity such as `Refresh for: *` message.
As every configuration server is also its own configuration client, it will attempt to refresh its own configuration and find no relevant changes (because there are no refresh scoped properties to update in the server application), as reflected in `Received remote refresh request. Keys refreshed []` message.


6. Refresh http://localhost:8080/message client endpoint; observe the value now matches the value updated in the file system.
The client application log will also reflect the change: `Received remote refresh request. Keys refreshed [example.message]`.

== Demo with GitHub

Keeping configuration in the local file system is simple, but not particularly useful -- if the configuration were available on the same file system as the client application, it could just get it without having to maintain a configuration server.
A more realistic scenario is keeping configuration under version control.

1. In the root of a GitHub repository, create a file named `application.properties` containing the following line:
+
----
example.message = message from GitHub
----

2. In configuration server's link:spring-cloud-gcp-pubsub-config-sample-server/src/main/resources/application.properties[application.properties]:
  * Comment out `spring.profiles.active` and `spring.cloud.config.server.native.searchLocations` properties.
  * Uncomment `spring.cloud.config.server.git.uri` property; set its value to either HTTPS or SSH repository URI.
  * If you opted for SSH, keys stored in `~/.ssh` should work automatically.
+
NOTE: make sure to set `spring.cloud.config.server.git.passphrase` property if the key registered with GitHub is passphrase protected.
  * If you opted for HTTPS, uncomment and set `spring.cloud.config.server.git.username` and `spring.cloud.config.server.git.password` properties.
+
CAUTION: Never commit any passwords or passphrases into source control.

3. In separate terminal windows, start the `spring-cloud-gcp-pubsub-config-sample-server-github` and `spring-cloud-gcp-pubsub-config-sample-client` applications:

  cd spring-cloud-gcp-samples/spring-cloud-gcp-pubsub-config-sample
  mvn spring-boot:run -pl spring-cloud-gcp-pubsub-config-sample-server-github

  cd spring-cloud-gcp-samples/spring-cloud-gcp-pubsub-config-sample
  mvn spring-boot:run -pl spring-cloud-gcp-pubsub-config-sample-client

4. Visit http://localhost:8080/message client in a browser; observe the correct value, "message from GitHub", printed on the page.

5. Push an update to configuration stored in GitHub, setting the message to a new value.

6. Notify the configuration server that new configuration is available.
In a deployed server, this would be done automatically through a GitHub webhook.
+
----
curl -X POST http://localhost:8888/monitor -H "X-Github-Event: push" -H "Content-Type: application/json" -d '{"commits": [{"modified": ["application.properties"]}]}'
----

7. Refresh http://localhost:8080/message client endpoint in a browser again; observe the value was updated.
